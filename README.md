Lab Work #2. Test Drive Development.
===
Due November 22nd.

==1. Acceptance tests
---

Describe 5 features of your application, each of them consisting of at least two scenarios of usage. Use the Gherkin description language and, after it, a Cucumber runner in your favorite language to run these tests.

Please keep them as simple as possible, you won't be able to write a fully-functional system in this lab. You'll need to pass through all the steps of TDD, so picking a feature that's easy to test is crucial.

*Example:*

You have the following scenario:

    Given that the server is down
    When I hit the refresh button
    Then I should see the message "Unfortunately, the server could not be accessed"

==2. Acceptance steps
---

Based on Cucumber's output, implement five of the scenarios with all the steps that were generated by Cucumber. After this step you should have five end-to end tests, which should fail.

Please make sure your steps contain as little of the application code as possible - ideally, there should be no code that deals with any of the application's internals. What driver options do you have for the selected language/platform?

*Example:*

The implementation of the first step would look something like (in a Java-like language):

    private final ApplicationRunner application = new ApplicationRunner();
    application.refresh();
    assert(application.displayedMessage(), "Unfortunately, the server could not be accessed);


==3. Integration tests
---

Your system is comprised of several functional blocks, the way you split them in the first lab. Now that you have an acceptance test suite, you can start implementing the functionality described in your Cucumber features.

For those scenarios for which you have chosen to implement steps, you should devise a set of functionalities of the application that would go towards making the acceptance tests pass. When you would plan this set of functionalities,



Now just writing this step told us that we have to have a `ServerConnection` instance, which would be a singleton, which should have a `testConnection()` method, which returns something that has a `status` method.
We don't have to test this in the acceptance test, since the purpose of the acceptance test is to check whether the message is displayed, given the conditions. Therefore, in this case, we'll have to stub out the `ServerConnection.getInstance().testConnection().status` line so that it would return something different than 200.


